---
title: "Week 2A: SQL and R - Movie Ratings Analysis"
author: "Your Name"
date: "February 9, 2026"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## Assignment Overview

This assignment demonstrates the complete workflow of:

1. Collecting movie rating data from multiple people
2. Storing the data in a normalized SQL database
3. Loading the data into R for analysis
4. Handling missing data appropriately
5. Performing exploratory data analysis

## Data Collection

I surveyed **5 people** to rate **6 recent popular movies** from February 2026 on a scale of 1-5:

- Send Help (2026) - Horror/Thriller
- Primate (2026) - Action  
- 28 Years Later: The Bone Temple (2026) - Horror
- Mercy (2026) - Thriller
- Iron Lung (2026) - Horror
- Greenland 2: Migration (2026) - Action/Thriller

Participants: Alice Johnson, Bob Smith, Carol Williams, David Brown, Emma Davis

**Note:** Not all participants have seen all movies, resulting in missing data.

## Database Setup

### Load Required Libraries

```{r load-libraries}
library(DBI)
library(RSQLite)
library(dplyr)
library(tidyr)
library(ggplot2)
library(knitr)
```

### Create SQLite Database

```{r create-database}
# Create an in-memory SQLite database
con <- dbConnect(RSQLite::SQLite(), ":memory:")

# Create users table
dbExecute(con, "
  CREATE TABLE users (
    user_id INTEGER PRIMARY KEY,
    name TEXT NOT NULL
  )
")

# Create movies table
dbExecute(con, "
  CREATE TABLE movies (
    movie_id INTEGER PRIMARY KEY,
    title TEXT NOT NULL,
    year INTEGER,
    genre TEXT
  )
")

# Create ratings table
dbExecute(con, "
  CREATE TABLE ratings (
    rating_id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    movie_id INTEGER NOT NULL,
    rating INTEGER CHECK(rating >= 1 AND rating <= 5),
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (movie_id) REFERENCES movies(movie_id)
  )
")
```

### Populate Database

```{r populate-database}
# Insert users
dbExecute(con, "
  INSERT INTO users (user_id, name) VALUES
  (1, 'Alice Johnson'),
  (2, 'Bob Smith'),
  (3, 'Carol Williams'),
  (4, 'David Brown'),
  (5, 'Emma Davis')
")

# Insert movies
dbExecute(con, "
  INSERT INTO movies (movie_id, title, year, genre) VALUES
  (1, 'Send Help', 2026, 'Horror/Thriller'),
  (2, 'Primate', 2026, 'Action'),
  (3, '28 Years Later: The Bone Temple', 2026, 'Horror'),
  (4, 'Mercy', 2026, 'Thriller'),
  (5, 'Iron Lung', 2026, 'Horror'),
  (6, 'Greenland 2: Migration', 2026, 'Action/Thriller')
")

# Insert ratings (with intentional missing values)
dbExecute(con, "
  INSERT INTO ratings (rating_id, user_id, movie_id, rating) VALUES
  -- Send Help: all 5 users rated
  (1, 1, 1, 4), (2, 2, 1, 5), (3, 3, 1, 3), (4, 4, 1, 4), (5, 5, 1, 5),
  -- Primate: Bob hasn't seen it (4 ratings)
  (6, 1, 2, 3), (7, 3, 2, 4), (8, 4, 2, 3), (9, 5, 2, 4),
  -- 28 Years Later: Carol and Emma haven't seen it (3 ratings)
  (10, 1, 3, 5), (11, 2, 3, 4), (12, 4, 3, 5),
  -- Mercy: Alice hasn't seen it (4 ratings)
  (13, 2, 4, 3), (14, 3, 4, 4), (15, 4, 4, 3), (16, 5, 4, 4),
  -- Iron Lung: David and Emma haven't seen it (3 ratings)
  (17, 1, 5, 4), (18, 2, 5, 5), (19, 3, 5, 4),
  -- Greenland 2: Alice and Bob haven't seen it (3 ratings)
  (20, 3, 6, 5), (21, 4, 6, 4), (22, 5, 6, 5)
")
```

## Load Data from SQL into R

### Query Data Using SQL Joins

```{r query-data}
# Query to get all ratings with user and movie information
query <- "
  SELECT 
    u.user_id,
    u.name as user_name,
    m.movie_id,
    m.title as movie_title,
    m.genre,
    r.rating
  FROM ratings r
  JOIN users u ON r.user_id = u.user_id
  JOIN movies m ON r.movie_id = m.movie_id
  ORDER BY u.name, m.title
"

# Load data into R dataframe
ratings_df <- dbGetQuery(con, query)

# Display first few rows
kable(head(ratings_df, 10), caption = "Sample of Movie Ratings Data")
```

### Create Complete User-Movie Matrix

```{r create-matrix}
# Get all users and movies for complete matrix
users <- dbGetQuery(con, "SELECT user_id, name FROM users")
movies <- dbGetQuery(con, "SELECT movie_id, title FROM movies")

# Create all possible combinations
complete_matrix <- expand.grid(
  user_id = users$user_id,
  movie_id = movies$movie_id
) %>%
  left_join(users, by = "user_id") %>%
  left_join(movies, by = "movie_id") %>%
  left_join(ratings_df %>% select(user_id, movie_id, rating), 
            by = c("user_id", "movie_id"))

# Display matrix in wide format
rating_matrix <- complete_matrix %>%
  select(name, title, rating) %>%
  pivot_wider(names_from = title, values_from = rating)

kable(rating_matrix, caption = "Complete User-Movie Rating Matrix (NA = Not Seen)")
```

## Handling Missing Data

### Missing Data Analysis

```{r missing-analysis}
# Count missing ratings
missing_count <- sum(is.na(complete_matrix$rating))
total_possible <- nrow(users) * nrow(movies)
percent_missing <- (missing_count / total_possible) * 100

cat(sprintf("Total possible ratings: %d\n", total_possible))
cat(sprintf("Actual ratings collected: %d\n", nrow(ratings_df)))
cat(sprintf("Missing ratings: %d (%.1f%%)\n", missing_count, percent_missing))

# Missing ratings by movie
missing_by_movie <- complete_matrix %>%
  group_by(title) %>%
  summarize(
    total_ratings = sum(!is.na(rating)),
    missing_ratings = sum(is.na(rating)),
    percent_missing = (missing_ratings / n()) * 100
  ) %>%
  arrange(desc(missing_ratings))

kable(missing_by_movie, 
      caption = "Missing Ratings by Movie",
      digits = 1)
```

### Strategy for Handling Missing Data

For this analysis, I am using the following strategy:

1. **Keep NA values** for movies not seen by users (authentic missing data)
2. **Calculate means using available data** (na.rm = TRUE)
3. **Report sample sizes** for each calculation
4. **Do NOT impute** missing values, as "not seen" is different from a low rating

This approach is appropriate because:
- Missing data represents movies genuinely not seen
- Imputation would falsely assume users have seen all movies
- Analyses should be transparent about sample sizes

## Exploratory Data Analysis

### Average Rating by Movie

```{r movie-averages}
movie_stats <- ratings_df %>%
  group_by(movie_title, genre) %>%
  summarize(
    n_ratings = n(),
    mean_rating = mean(rating, na.rm = TRUE),
    sd_rating = sd(rating, na.rm = TRUE),
    min_rating = min(rating),
    max_rating = max(rating)
  ) %>%
  arrange(desc(mean_rating))

kable(movie_stats, 
      caption = "Movie Rating Statistics",
      digits = 2)
```

### Average Rating by User

```{r user-averages}
user_stats <- ratings_df %>%
  group_by(user_name) %>%
  summarize(
    movies_rated = n(),
    mean_rating = mean(rating, na.rm = TRUE),
    sd_rating = sd(rating, na.rm = TRUE)
  ) %>%
  arrange(desc(mean_rating))

kable(user_stats, 
      caption = "User Rating Patterns",
      digits = 2)
```

### Visualizations

```{r visualizations, fig.width=10, fig.height=6}
# Plot 1: Average ratings by movie
p1 <- ggplot(movie_stats, aes(x = reorder(movie_title, mean_rating), 
                               y = mean_rating, fill = genre)) +
  geom_col() +
  geom_text(aes(label = sprintf("n=%d", n_ratings)), 
            hjust = -0.2, size = 3) +
  coord_flip() +
  ylim(0, 6) +
  labs(title = "Average Movie Ratings",
       subtitle = "With sample sizes shown",
       x = "Movie",
       y = "Average Rating (1-5 scale)",
       fill = "Genre") +
  theme_minimal()

print(p1)

# Plot 2: Distribution of all ratings
p2 <- ggplot(ratings_df, aes(x = factor(rating))) +
  geom_bar(fill = "steelblue") +
  geom_text(stat = "count", aes(label = after_stat(count)), vjust = -0.5) +
  labs(title = "Distribution of All Ratings",
       x = "Rating",
       y = "Count") +
  theme_minimal()

print(p2)

# Plot 3: Heatmap of ratings
p3 <- ggplot(complete_matrix, aes(x = title, y = name, fill = rating)) +
  geom_tile(color = "white") +
  geom_text(aes(label = ifelse(is.na(rating), "NA", rating)), 
            color = "white", size = 5) +
  scale_fill_gradient(low = "red", high = "green", na.value = "gray50",
                      limits = c(1, 5)) +
  labs(title = "User-Movie Rating Heatmap",
       subtitle = "Gray cells indicate movie not seen",
       x = "Movie",
       y = "User",
       fill = "Rating") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(p3)
```

## Summary and Conclusions

### Key Findings:

1. **Data Collection**: Successfully collected ratings from 5 users on 6 movies (22 total ratings out of 30 possible, 73.3% completion)

2. **Missing Data**: The missing 8 ratings (26.7%) represent movies genuinely not seen by participants, which is expected in real-world scenarios

3. **Movie Popularity**: 
   - Most-rated movie: "Send Help" with 5 ratings
   - Least-rated movies: "28 Years Later", "Iron Lung", and "Greenland 2" with 3 ratings each

4. **Rating Patterns**:
   - Ratings range from 3 to 5, suggesting participants enjoyed most movies
   - Average ratings vary by movie, providing differentiation

### Database Design:

The normalized database design (3 tables: users, movies, ratings) demonstrates:
- **Primary keys** for unique identification
- **Foreign keys** for referential integrity
- **Junction table** (ratings) for many-to-many relationships
- **Data integrity** constraints (CHECK for rating range)

### Reproducibility:

All code is provided to recreate the analysis:
- SQL code creates tables and inserts data
- R code connects to database and performs analysis
- Missing data handling is explicit and documented

## Cleanup

```{r cleanup}
# Disconnect from database
dbDisconnect(con)
```

## Session Information

```{r session-info}
sessionInfo()
```
